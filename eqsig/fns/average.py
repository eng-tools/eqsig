import numpy as np
from .time_shift import time_indices


def get_section_average(series, start=0, end=-1, index=False):
    """
    Gets the average value of a part of series.

    Common use is so that it can be patched with another record.

    :param series: A TimeSeries object
    :param start: int or float, optional,
        Section start point
    :param end: int or float, optional,
        Section end point
    :param index: bool, optional,
        if False then start and end are considered values in time.
    :return float,
        The mean value of the section.
    """
    s_index, e_index = time_indices(series.npts, series.dt, start, end, index)

    section_average = np.mean(series.values[s_index:e_index])
    return section_average


def calc_step_fn_vals_error(values, pow=1, dir=None):
    """
    Calculates the error function generated by fitting a step function
    to the values

    Note: Assumes minimum error is at the minimum sum of the error,
    regardless of the `pow`. I.e. The best fit is taken as the mean
    of the values.

    Parameters
    ----------
    values: array_like
    pow: int
        The power that the error should be raised to
    dir: str
        Desired direction of the step function
        if 'down', then all upward steps are set to 10x maximum error
        if 'up', then all downward steps are set to 10x maximum error
        else, no modification to error

    Returns
    -------
    array_like (len same as input array)
    """
    values = np.array(values)
    npts = len(values)
    pre_a = np.tril(values, k=0)
    post_a = np.triu(values, k=0)
    pre_n = np.arange(1, len(values) + 1)
    post_n = np.arange(len(values), 0, -1)
    pre_mean = np.sum(pre_a, axis=1) / pre_n
    post_mean = np.sum(post_a, axis=1) / post_n
    err_pre = np.sum(np.abs(pre_a - pre_mean[:, np.newaxis]) ** pow, axis=1) - (npts - pre_n) * pre_mean ** pow
    err_post = np.sum(np.abs(post_a - post_mean[:, np.newaxis]) ** pow, axis=1) - (npts - post_n) * post_mean ** pow
    # case of 0 has been remove, n + 1 options
    # consider cases where it happens in between two steps
    err = np.ones_like(values)
    err[:-1] = err_post[1:] + err_pre[:-1]
    err[-1] = np.sum(np.abs(values - np.mean(values)) ** pow)
    if dir == 'down':  # if step has to be downward, then increase error for upward steps
        max_err = np.max(err)
        err = np.where(pre_mean < post_mean, max_err * 10, err)
    if dir == 'up':
        max_err = np.max(err)
        err = np.where(pre_mean > post_mean, max_err * 10, err)
    return err


def calc_step_fn_steps_vals(values, ind=None):
    if ind is None:
        ind = np.argmin(calc_step_fn_vals_error(values))
    pre = np.mean(values[:ind])
    post = np.mean(values[ind + 1:])
    return pre, post


def calc_roll_av_vals(values, steps, mode='forward'):
    """
    Calculates the rolling average of a series of values

    Parameters
    ----------
    values: array_like
    steps: int
        size of window to average over
    mode: str (default='forward')
        if 'forward' current value at start of window
        if 'backward' current value at end of window
        if 'centre' or 'center' current value in centre of window

    Returns
    -------
    array_like (len same as input array)
    """
    values = np.array(values)
    steps = int(steps)
    if mode == 'forward':
        x_ext = np.concatenate([values, values[-1] * np.ones(steps - 1)])
    elif mode == 'backward':
        x_ext = np.concatenate([values[0] * np.ones(steps - 1), values])
    else:
        s = int(np.floor(steps / 2))
        e = steps - s - 1
        x_ext = np.concatenate([values[0] * np.ones(s), values, values[-1] * np.ones(e)])
    csum = np.zeros(len(values) + steps)
    csum[1:] = np.cumsum(x_ext, dtype=float)

    return (csum[steps:] - csum[:-steps]) / steps
